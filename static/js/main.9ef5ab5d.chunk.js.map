{"version":3,"sources":["components/ControlPanel.js","components/Family.js","components/Population.js","components/InitialPop.js","components/Generations.js","components/DataPanel.js","algorithm/Algorithm.js","App.js","serviceWorker.js","index.js"],"names":["ControlPanel","props","handleChange","bind","handleColorChange","handleReset","handleSubmit","event","target","value","parseFloat","name","state","this","onControlPanelChange","color","optimal","rgb","stopInterval","generations","stats","fitnessOverTime","stdDevOverTime","lowestFitness","highestFitness","preventDefault","onControlPanelSubmit","className","onSubmit","type","popSize","onChange","min","deathCutoff","maxGens","displayInterval","mutationRate","max","step","disableAlpha","onClick","React","Component","Family","mommy","Spectra","hex","daddy","child","style","backgroundColor","fitness","Population","pop","population","listPop","individuals","map","individual","generation","Generations","genList","filter","InitialPop","key","toString","DataPanel","currentFitness","averageFitness","prevGen","cur","i","x","y","length","height","width","title","data","yDomain","Algorithm","Math","floor","random","r","getRandomInt","g","b","spectraLab","labObject","L","l","A","a","B","valueLAB","convertToLab","optimalLAB","DeltaE","getDeltaE00","toFixed","newColor","push","calculateFitness","death","selectionPop","selection","nextGen","crossover","mutation","assignFitness","updateCounter","newIndividuals","pairs","pair","randWeightedInd","nextPair","weightSums","reduce","acc","randNum","j","sel","nextPop","nextInd","mate","mommyGene","colorToGene","daddyGene","crossPnt","babyGene","substring","geneToColor","pad","num","s","gene","parseInt","ind","sign","mutationVal","delta","round","rand_bm","newValue","skew","u","v","sqrt","log","cos","PI","pow","App","alg","handleControlPanelChange","handleControlPanelSubmit","setState","clearInterval","genInterval","initialGen","generateStartingPop","calculateAverageFitness","calculateStdDevFitness","findLowestFitness","findHighestFitness","setInterval","gens","gen","fitnessArr","n","mean","highest","lowest","href","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.9ef5ab5d.chunk.js","sourcesContent":["import React from 'react';\r\nimport { ChromePicker } from 'react-color';\r\nimport '../components/ControlPanel.css';\r\n\r\nclass ControlPanel extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.handleChange = this.handleChange.bind(this);\r\n        this.handleColorChange = this.handleColorChange.bind(this);\r\n        this.handleReset = this.handleReset.bind(this);\r\n        this.handleSubmit = this.handleSubmit.bind(this);\r\n    }\r\n\r\n\r\n    // handles changes to the control panel except color changes\r\n    handleChange(event) {\r\n        const target = event.target;\r\n        const value = parseFloat(target.value);\r\n        const name = target.name;\r\n\r\n        const state = {\r\n            [name]: value,\r\n        };\r\n\r\n        this.props.onControlPanelChange(state);\r\n    }\r\n\r\n    // handles color changes on control panel\r\n    handleColorChange(color) {\r\n        const state = {\r\n            optimal: color.rgb,\r\n        };\r\n        this.props.onControlPanelChange(state);\r\n    }\r\n\r\n    handleReset() {\r\n        const state = {\r\n            generations: [],\r\n            stats: {\r\n                fitnessOverTime: [],\r\n                stdDevOverTime: [],\r\n                lowestFitness: 100,\r\n                highestFitness: 0,\r\n            },\r\n        };\r\n        this.props.stopInterval();\r\n        this.props.onControlPanelChange(state);\r\n    }\r\n\r\n    // begins the algorithm\r\n    handleSubmit(event) {\r\n        event.preventDefault();\r\n        this.props.onControlPanelSubmit();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"ControlPanel\">\r\n                <form onSubmit={this.handleSubmit}>\r\n                    <label>\r\n                        Population Size:\r\n                        <input name=\"popSize\" type=\"number\" value={this.props.popSize} onChange={this.handleChange} min=\"2\"/>\r\n                    </label>\r\n                    <br />\r\n                    <label>\r\n                        Death Cutoff:\r\n                        <input name=\"deathCutoff\" type=\"number\" value={this.props.deathCutoff} onChange={this.handleChange} />\r\n                    </label>\r\n                    <br />\r\n                    <label>\r\n                        Max Generations:\r\n                        <input name=\"maxGens\" type=\"number\" value={this.props.maxGens} onChange={this.handleChange} />\r\n                    </label>\r\n                    <br />\r\n                    <label>\r\n                        Display Every:\r\n                        <input name=\"displayInterval\" type=\"number\" value={this.props.displayInterval} onChange={this.handleChange} min=\"1\"/>\r\n                    </label>\r\n                    <br />\r\n                    <label>\r\n                        Mutation Rate:\r\n                        <input name=\"mutationRate\" type=\"number\" value={this.props.mutationRate} onChange={this.handleChange} min=\"0\" max=\"1\" step=\"0.001\"/>\r\n                    </label>\r\n                    <br />\r\n                    <label className={'colorPicker'}>\r\n                        Optimal Color:\r\n                        <ChromePicker\r\n                            className={'chromePicker'}\r\n                            color={this.props.optimal}\r\n                            onChange={this.handleColorChange}\r\n                            disableAlpha={true}\r\n                        />\r\n                    </label>\r\n                    <br/>\r\n                    <input type=\"submit\" value=\"Start\" />\r\n                    <br/>\r\n                    <input type=\"button\" value=\"Reset\" onClick={this.handleReset}/>\r\n                </form>\r\n\r\n            </div>\r\n\r\n        );\r\n    }\r\n}\r\n\r\n\r\nexport default ControlPanel;\r\n","import React from 'react';\r\nimport '../components/Family.css';\r\nimport Spectra from \"spectra\";\r\n\r\n\r\nfunction Family(props) {\r\n    // convert to hex to use in CSS\r\n    const mommy = Spectra(props.mommy.value).hex();\r\n    const daddy = Spectra(props.daddy.value).hex();\r\n    const child = Spectra(props.child.value).hex();\r\n\r\n    return (\r\n        <div className={'container'}>\r\n            <div>\r\n                <div className={'individual'} style={{backgroundColor: mommy}}>{props.mommy.fitness}</div>\r\n                <div className={'individual'} style={{backgroundColor: daddy}}>{props.daddy.fitness}</div>\r\n            </div>\r\n            <div className={'arrow'}>&#8594;</div>\r\n            <div>\r\n                <div className={'individual'} style={{backgroundColor: child}}>{props.child.fitness}</div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Family;\r\n","import React from 'react';\r\nimport '../components/Population.css';\r\nimport Family from \"./Family\";\r\n\r\nfunction Population(props) {\r\n    const pop = props.population;\r\n\r\n    const listPop = pop.individuals.map((individual) =>\r\n        <Family\r\n            mommy={individual.mommy}\r\n            daddy={individual.daddy}\r\n            child={individual}\r\n        />\r\n    );\r\n\r\n    return (\r\n        <div className=\"Population\">\r\n            Generation: {pop.generation}\r\n            <div className=\"PopulationList\">\r\n                {listPop}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Population;","import React from 'react';\r\nimport Spectra from 'spectra';\r\n\r\nfunction Population(props) {\r\n    const pop = props.population;\r\n    const listPop = pop.individuals.map((individual) => {\r\n        // convert to hex to use in CSS\r\n        const color = Spectra(individual.value).hex();\r\n\r\n        return (\r\n            <div className=\"container\" style={{backgroundColor: color}}>\r\n                {individual.fitness}\r\n            </div>\r\n        );\r\n    });\r\n\r\n    return (\r\n        <div className=\"Population\">\r\n            Initial Population\r\n            <div className=\"PopulationList\">\r\n                {listPop}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Population;\r\n","import React from 'react';\r\nimport Population from './Population.js';\r\nimport InitialPop from './InitialPop.js';\r\nimport '../components/Generations.css';\r\n\r\nfunction Generations(props) {\r\n\r\n    const genList = props.generations.filter((pop) => {\r\n        // first, only show every nth generation\r\n        return pop.generation % props.displayInterval === 0;\r\n    }).map((pop) => {\r\n        // then, render as components\r\n        // render the first generation differently\r\n        if (pop.generation === 0) {\r\n            return <InitialPop key={pop.generation.toString()} population={pop} />\r\n        }\r\n        return <Population key={pop.generation.toString()} population={pop}/>\r\n    });\r\n\r\n    if (genList[0]) {\r\n        return (\r\n            <div>\r\n                <hr />\r\n                <div className=\"Generations\">\r\n                    {genList}\r\n                </div>\r\n            </div>\r\n        );\r\n    } else return null;\r\n}\r\n\r\nexport default Generations;\r\n","import React from 'react';\r\nimport {HorizontalGridLines, LineSeries, VerticalGridLines, XAxis, XYPlot, YAxis, MarkSeries} from \"react-vis\";\r\nimport '../../node_modules/react-vis/dist/style.css';\r\nimport '../components/DataPanel.css'\r\n\r\nfunction DataPanel(props) {\r\n\r\n    let currentFitness;\r\n    let averageFitness;\r\n    let generation;\r\n\r\n    if (props.prevGen) { // ensure the props exist\r\n        currentFitness = props.prevGen.individuals.map((cur, i) => {\r\n            return {\r\n                x: i,\r\n                y: cur.fitness,\r\n            }\r\n        });\r\n\r\n       averageFitness = props.stats.fitnessOverTime[props.stats.fitnessOverTime.length - 1].y;\r\n       generation = props.prevGen.generation;\r\n    }\r\n\r\n\r\n\r\n\r\n    return (\r\n        <div className=\"DataPanel\">\r\n            <div className=\"Data\">\r\n                <XYPlot height={300} width={300}>\r\n                    <VerticalGridLines />\r\n                    <HorizontalGridLines />\r\n                    <XAxis title=\"Generation\"/>\r\n                    <YAxis title=\"Fitness\"/>\r\n                    <LineSeries data={props.stats.fitnessOverTime}/>\r\n                </XYPlot>\r\n            </div>\r\n            <div className=\"Data\">\r\n                <XYPlot yDomain={[0, 100]}\r\n                        height={300}\r\n                        width={300}>\r\n                    <VerticalGridLines />\r\n                    <HorizontalGridLines />\r\n                    <XAxis title=\"Individual\"/>\r\n                    <YAxis title=\"Fitness\"/>\r\n                    <MarkSeries data={currentFitness}/>\r\n                </XYPlot>\r\n            </div>\r\n            <div className=\"Data\">\r\n                <XYPlot height={300} width={300}>\r\n                    <VerticalGridLines />\r\n                    <HorizontalGridLines />\r\n                    <XAxis title=\"Generation\"/>\r\n                    <YAxis title=\"Standard Deviation of Fitness\"/>\r\n                    <LineSeries data={props.stats.stdDevOverTime}/>\r\n                </XYPlot>\r\n            </div>\r\n            <div className=\"Info\">\r\n                <div>Generation: {generation}</div>\r\n                <div>Lowest Fitness: {props.stats.lowestFitness}</div>\r\n                <div>Highest Fitness: {props.stats.highestFitness}</div>\r\n                <div>Average Fitness: {averageFitness}</div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default DataPanel;\r\n","import DeltaE from 'delta-e';\r\nimport Spectra from 'spectra';\r\n\r\nclass Algorithm {\r\n\r\n    getRandomInt(min, max) {\r\n        return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    }\r\n\r\n    // generates a colour in RGB colour space\r\n    newColor() {\r\n        let r = this.getRandomInt(0, 255);\r\n        let g = this.getRandomInt(0, 255);\r\n        let b = this.getRandomInt(0, 255);\r\n        return {r: r, g: g, b: b};\r\n    }\r\n\r\n    // convert RGB to LAB\r\n    convertToLab(color) {\r\n        /*\r\n            It seems like DeltaE doesn't like the LAB object provided by Spectra.\r\n            So this function converts them so they work together nicely :D\r\n         */\r\n        const spectraLab = Spectra(color).labObject();\r\n        const lab = {\r\n            L: spectraLab.l,\r\n            A: spectraLab.a,\r\n            B: spectraLab.b,\r\n        }\r\n        return lab;\r\n    }\r\n\r\n    calculateFitness(value, optimal) {\r\n        // convert to LAB for comparison\r\n        const valueLAB = this.convertToLab(value);\r\n        const optimalLAB = this.convertToLab(optimal);\r\n\r\n        // DeltaE is 0 when there's no difference\r\n        // I subtract from 100 so that 100 is the optimal fitness\r\n        const fitness = 100 - DeltaE.getDeltaE00(valueLAB, optimalLAB);\r\n\r\n        return parseFloat(fitness.toFixed(1));\r\n    }\r\n\r\n    generateStartingPop(popSize, optimal, deathCutoff) {\r\n        // initialize population\r\n        let population = {\r\n            generation: 0,\r\n            individuals: [],\r\n        };\r\n\r\n        // add individuals to population\r\n        for (let i = 0; i < popSize; i++) {\r\n            // create new color\r\n            const value = this.newColor();\r\n\r\n            population.individuals.push({\r\n                value: value,\r\n                fitness: this.calculateFitness(value, optimal),\r\n            });\r\n        }\r\n\r\n        // remove the weaklings before returning\r\n        return this.death(population, deathCutoff);\r\n    }\r\n\r\n    // compute the next generation\r\n    nextGen(prevGen, popSize, optimal, deathCutoff, mutationRate) {\r\n\r\n        // the population is grouped into pairs for breeding\r\n        // I temporarily change the object for the selection\r\n        let selectionPop = this.selection(prevGen, popSize);\r\n\r\n        // the pairs will now breed\r\n        let nextGen = this.crossover(selectionPop);\r\n\r\n        // add mutations\r\n        nextGen = this.mutation(nextGen, mutationRate);\r\n\r\n        // calculate fitness\r\n        nextGen = this.assignFitness(nextGen, optimal);\r\n\r\n        // update counter\r\n        nextGen = this.updateCounter(nextGen);\r\n\r\n        // remove the weaklings\r\n        nextGen = this.death(nextGen, deathCutoff);\r\n\r\n        return nextGen;\r\n    }\r\n\r\n    // remove individuals with fitness below cutoff\r\n    death(pop, deathCutoff) {\r\n        const newIndividuals = pop.individuals.filter(i => i.fitness >= deathCutoff);\r\n        return {\r\n            ...pop,\r\n            individuals: newIndividuals,\r\n        };\r\n    }\r\n\r\n    selection(pop, popSize) {\r\n        // selectionPop object contains pairs for the crossover step later on\r\n        const selectionPop = {\r\n            generation: pop.generation,\r\n            pairs: [],\r\n        };\r\n\r\n        /*\r\n            Population breeds until popSize is full.\r\n            The more fit, the more likely an individual is to breed.\r\n         */\r\n        const individuals = pop.individuals;\r\n        for (let i = 0; i < popSize; i++) {\r\n\r\n            // pair is two individuals who will mate\r\n            let pair = []; //\r\n\r\n            const individual = this.randWeightedInd(individuals);\r\n            pair.push(individual); // push random individual to pair\r\n\r\n            // ensure an individual is not paired with itself\r\n            // this is really not ideal TODO figure out a better way\r\n            let nextPair;\r\n            do {\r\n                nextPair = this.randWeightedInd(individuals); // next in pair\r\n                pair[1] = nextPair; // assign random individual to next spot\r\n            } while (nextPair === pair[0]) // do this until the pair has distinct members\r\n\r\n            // once that's done, push it to pairs\r\n            selectionPop.pairs.push(pair);\r\n        }\r\n        return selectionPop;\r\n    }\r\n\r\n    // returns an individual randomly based on their fitness\r\n    randWeightedInd(individuals) {\r\n        // sum of fitness\r\n        const indFitness = individuals.map(x => x.fitness);\r\n        const weightSums = indFitness.reduce((acc, cur) => acc + cur);\r\n        let randNum = this.getRandomInt(0, weightSums); // random value from 0 to weightSums\r\n\r\n        for (let j = 0; j < individuals.length; j++) {\r\n            if (randNum < individuals[j].fitness) {\r\n                return individuals[j];\r\n            }\r\n            randNum -= individuals[j].fitness;\r\n        }\r\n\r\n        // if loop ends with no return, return last element\r\n        // this shouldn't introduce much of a bias, as the last one would have been picked if it weren't for rounding issues\r\n        return individuals[individuals.length - 1];\r\n    }\r\n\r\n    // combine color values\r\n    crossover(sel) {\r\n        // recreate population object\r\n        let nextPop = {\r\n            generation: sel.generation,\r\n            individuals: [],\r\n        };\r\n\r\n        // combine each pair into one individual\r\n        for (let i = 0; i < sel.pairs.length; i++) {\r\n            let nextInd = this.mate(sel.pairs[i]);\r\n            nextPop.individuals.push(nextInd);\r\n        }\r\n\r\n        return nextPop;\r\n    }\r\n\r\n    // breed one pair\r\n    mate(pair) {\r\n        const mommy = pair[0]; // mommy and daddy have no meaning\r\n        const daddy = pair[1]; // gender does not exist in this universe\r\n\r\n\r\n        /*\r\n            Convert all color values to string, and pad with 0s to reach 3 digits.\r\n            CrossPnt chooses where to cross the parent's color info.\r\n            --> from 1 to 8 to ensure baby is not the exact same as one of the parents\r\n            Then the string will be split back into color info\r\n        */\r\n        const mommyGene = this.colorToGene(mommy.value);\r\n        const daddyGene = this.colorToGene(daddy.value);\r\n\r\n        const crossPnt = this.getRandomInt(1, 8);\r\n        const babyGene = mommyGene.substring(0, crossPnt) + daddyGene.substring(crossPnt);\r\n\r\n        const baby = {\r\n            value: this.geneToColor(babyGene),\r\n            fitness: 0, // fitness will be calculated after mutations\r\n            mommy: {\r\n                value: mommy.value,\r\n                fitness: mommy.fitness,\r\n            },\r\n            daddy: {\r\n                value: daddy.value,\r\n                fitness: daddy.fitness,\r\n            },\r\n        }\r\n\r\n        return baby;\r\n    }\r\n\r\n    // return string of all padded rgb values\r\n    colorToGene(color) {\r\n        const R = this.pad(color.r);\r\n        const G = this.pad(color.g);\r\n        const B = this.pad(color.b);\r\n        return R + G + B;\r\n    }\r\n\r\n    // add 0s before number until it's 3 digits long and return as string\r\n    pad(num) {\r\n        let s = num.toString();\r\n\r\n        for (let i = s.length; i < 3; i++) {\r\n            s = \"0\" + s;\r\n        }\r\n\r\n        return s;\r\n    }\r\n\r\n    // takes gene string, converts to RGB color\r\n    geneToColor(gene) {\r\n        const color = {\r\n            r: parseInt(gene.substring(0, 3)),\r\n            g: parseInt(gene.substring(3, 6)),\r\n            b: parseInt(gene.substring(6, 9)),\r\n        };\r\n        return color;\r\n    }\r\n\r\n    // occasionally add or subtract random amounts from the individual's RGB values\r\n    mutation(pop, mutationRate) {\r\n\r\n        for (let i = 0; i < pop.individuals.length; i++) {\r\n            const ind = pop.individuals[i];\r\n\r\n            if (Math.random() < mutationRate) {\r\n\r\n                const sign = Math.random() < 0.5 ? -1 : 1; // adding or subtracting?\r\n\r\n                const mutationVal = this.getRandomInt(0, 2); // which value will be modified? (R, G, or B)\r\n\r\n                // a random integer that tends to be fairly small, but can be larger\r\n                const delta = Math.round(this.rand_bm(0, 255, 5));\r\n\r\n                let newValue;\r\n\r\n                switch(mutationVal) {\r\n                    case 0:\r\n                        newValue = ind.value.r + (delta * sign);\r\n                        pop.individuals[i].value.r = Math.min(newValue, 255);\r\n                        break;\r\n                    case 1:\r\n                        newValue = ind.value.g + (delta * sign);\r\n                        pop.individuals[i].value.g = Math.min(newValue, 255);\r\n                        break;\r\n                    case 2:\r\n                        newValue = ind.value.b + (delta * sign);\r\n                        pop.individuals[i].value.b = Math.min(newValue, 255);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return pop;\r\n    }\r\n\r\n    // Boxâ€“Muller transform to give random numbers that tend to be in a specific range, but can be larger or smaller.\r\n    // from https://stackoverflow.com/a/49434653\r\n    rand_bm (min, max, skew) {\r\n        let u = 0, v = 0;\r\n        while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\r\n        while(v === 0) v = Math.random();\r\n        let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\r\n\r\n        num = num / 10.0 + 0.5; // Translate to 0 -> 1\r\n        if (num > 1 || num < 0) num = this.rand_bm(min, max, skew); // re sample between 0 and 1 if out of range\r\n        num = Math.pow(num, skew); // Skew\r\n        num *= max - min; // Stretch to fill range\r\n        num += min; // offset to min\r\n        return num;\r\n    }\r\n\r\n    assignFitness(pop, optimal) {\r\n        for (let i = 0; i < pop.individuals.length; i++) {\r\n            const value = pop.individuals[i].value;\r\n            pop.individuals[i].fitness = this.calculateFitness(value, optimal);\r\n        }\r\n\r\n        return pop;\r\n    }\r\n\r\n    // this could have been done earlier, but I make it it's own step for clarity\r\n    updateCounter(pop) {\r\n        return {\r\n            generation: pop.generation + 1,\r\n            individuals: pop.individuals,\r\n        };\r\n    }\r\n}\r\n\r\nexport default Algorithm;\r\n","import React from 'react';\r\nimport './App.css';\r\nimport ControlPanel from \"./components/ControlPanel\";\r\nimport Generations from \"./components/Generations\";\r\nimport DataPanel from \"./components/DataPanel\";\r\nimport Algorithm from \"./algorithm/Algorithm\";\r\n\r\nclass App extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.alg = new Algorithm();\r\n\r\n        this.state = {\r\n            popSize: 50,\r\n            deathCutoff: 5, // determines min fitness to survive\r\n            maxGens: 50, // prevent infinite loops (hopefully less necessary once convergence is written)\r\n            mutationRate: 0.01, // the chance a mutation will occur for each individual in the population\r\n            displayInterval: 25, // show every n generations\r\n            optimal: this.alg.newColor(), // Optimal individual in environment (in RGB, but converted to LAB for fitness calculation)\r\n            generations: [],\r\n            stats: {\r\n                fitnessOverTime: [],\r\n                stdDevOverTime: [],\r\n                lowestFitness: 100,\r\n                highestFitness: 0,\r\n            },\r\n        }\r\n\r\n        this.handleControlPanelChange = this.handleControlPanelChange.bind(this);\r\n        this.handleControlPanelSubmit = this.handleControlPanelSubmit.bind(this);\r\n        this.stopInterval = this.stopInterval.bind(this);\r\n    }\r\n\r\n\r\n    handleControlPanelChange(state) {\r\n        this.setState(state);\r\n    }\r\n\r\n    handleControlPanelSubmit() {\r\n        clearInterval(this.genInterval);\r\n\r\n        const initialGen = this.alg.generateStartingPop(this.state.popSize, this.state.optimal, this.state.deathCutoff);\r\n\r\n        this.setState({\r\n            generations: [initialGen],\r\n            stats: {\r\n                fitnessOverTime: [this.calculateAverageFitness(initialGen)],\r\n                stdDevOverTime: [this.calculateStdDevFitness(initialGen)],\r\n                lowestFitness: this.findLowestFitness(100, initialGen),\r\n                highestFitness: this.findHighestFitness(0, initialGen),\r\n            }\r\n        });\r\n\r\n        this.genInterval = setInterval(\r\n            () => this.nextGen(),\r\n            0,\r\n        );\r\n    }\r\n\r\n    nextGen() {\r\n        const gens = this.state.generations;\r\n        const prevGen = gens[gens.length - 1];\r\n\r\n        // stop after max number of generations\r\n        if (prevGen.generation >= this.state.maxGens) {\r\n            clearInterval(this.genInterval);\r\n            return;\r\n        }\r\n\r\n        const popSize = this.state.popSize;\r\n        const optimal = this.state.optimal;\r\n        const deathCutoff = this.state.deathCutoff;\r\n        const mutationRate = this.state.mutationRate;\r\n\r\n        // create next generation\r\n        const nextGen = this.alg.nextGen(prevGen, popSize, optimal, deathCutoff, mutationRate);\r\n\r\n\r\n        // ensure next generation can actually repopulate. Otherwise end simulation\r\n        if (nextGen.individuals.length > 1) {\r\n            gens.push(nextGen);\r\n\r\n            // update stats\r\n            const stats = this.state.stats;\r\n            let fitnessOverTime = stats.fitnessOverTime;\r\n            let stdDevOverTime = stats.stdDevOverTime;\r\n            let lowestFitness = stats.lowestFitness;\r\n            let highestFitness = stats.highestFitness;\r\n            fitnessOverTime.push(this.calculateAverageFitness(nextGen));\r\n            stdDevOverTime.push(this.calculateStdDevFitness(nextGen));\r\n            lowestFitness = this.findLowestFitness(lowestFitness, nextGen);\r\n            highestFitness = this.findHighestFitness(highestFitness, nextGen);\r\n\r\n            // update state\r\n            this.setState({\r\n                generations: gens,\r\n                stats: {\r\n                    fitnessOverTime: fitnessOverTime,\r\n                    stdDevOverTime: stdDevOverTime,\r\n                    lowestFitness: lowestFitness,\r\n                    highestFitness: highestFitness,\r\n                },\r\n            });\r\n        } else {\r\n            clearInterval(this.genInterval);\r\n        }\r\n    }\r\n\r\n    // this allows control panel to reset interval\r\n    stopInterval() {\r\n        clearInterval(this.genInterval);\r\n    }\r\n\r\n    // calculates average fitness and returns as object for data visualization.\r\n    calculateAverageFitness(gen) {\r\n        const x = gen.generation;\r\n        let pop = gen.individuals;\r\n        const y = (pop.reduce((acc, cur) => acc + parseFloat(cur.fitness), 0) / pop.length).toFixed(1); // find average\r\n        return {\r\n            x: x,\r\n            y: y,\r\n        };\r\n    }\r\n\r\n    // calculates the standard deviation of the fitness and returns as object for data visualisation.\r\n    calculateStdDevFitness(gen) {\r\n        const x = gen.generation;\r\n        const fitnessArr = gen.individuals.map((cur) => cur.fitness);\r\n        const n = fitnessArr.length\r\n        const mean = fitnessArr.reduce((a, b) => a + b) / n\r\n        const y = Math.sqrt(fitnessArr.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);\r\n        return {\r\n            x: x,\r\n            y: y,\r\n        }\r\n    }\r\n\r\n    findHighestFitness(highest, gen) {\r\n        const fitnessArr = gen.individuals.map((cur) => cur.fitness);\r\n        return Math.max(...fitnessArr, highest);\r\n    }\r\n\r\n    findLowestFitness(lowest, gen) {\r\n        const fitnessArr = gen.individuals.map((cur) => cur.fitness);\r\n        return Math.min(...fitnessArr, lowest);\r\n    }\r\n\r\n\r\n    render() {\r\n        const gens = this.state.generations;\r\n        const prevGen = this.state.generations[this.state.generations.length - 1];\r\n\r\n        return (\r\n            <div className=\"App\">\r\n                <h1>Genetic Algorithm</h1>\r\n                <h5>By Aiden Kerr</h5>\r\n                <a href=\"https://github.com/AidenKerr/genetic-v2/blob/master/README.md\">What is this? Click Here!</a>\r\n                <ControlPanel\r\n                    popSize={this.state.popSize}\r\n                    deathCutoff={this.state.deathCutoff}\r\n                    maxGens={this.state.maxGens}\r\n                    mutationRate={this.state.mutationRate}\r\n                    displayInterval={this.state.displayInterval}\r\n                    optimal={this.state.optimal}\r\n                    onControlPanelChange={this.handleControlPanelChange}\r\n                    onControlPanelSubmit={this.handleControlPanelSubmit}\r\n                    stopInterval={this.stopInterval}\r\n                />\r\n                <DataPanel stats={this.state.stats} prevGen={prevGen}/>\r\n                <Generations\r\n                    generations={gens}\r\n                    displayInterval={this.state.displayInterval}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n    <React.StrictMode>\r\n        <App/>\r\n    </React.StrictMode>,\r\n    document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}